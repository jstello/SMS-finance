# Finanzas Personales Android App Documentation (Offline-Only Edition)

## Overview
A personal finance management Android application that automatically tracks transactions from SMS messages and manual entries, with **all data stored locally in an on-device SQL database**. Key features include:
- SMS transaction parsing for Colombian financial institutions
- Transaction categorization system
- **Local data persistence using Room**
- Provider recognition and contact matching
- Spending analytics by category/provider
- **Time-series spending visualizations**
- Data statistics summary (total transactions, date range)
- Provider-category mapping/rules stored in SharedPreferences.

## Key Technical Components

### 1. Core Architecture (Offline-First)
```
app/
├── data/
│   ├── local/           # SMS processing, SharedPreferences, Room DB components
│   │   ├── room/
│   │   │   ├── dao/
│   │   │   └── (Entities, Database, Converters directly under local/room)
│   │   └── (SmsDataSource.kt, SharedPrefsManager.kt directly under local/)
│   ├── db/
│   │   └── mapper/      # Room Entity to Domain model mappers
│   ├── model/           # Data classes (TransactionData, Category, SmsMessage, AccountInfo)
│   ├── repository/      # Main business logic (interacts with Room DAOs, SmsDataSource, SharedPrefsManager)
│   └── sms/             # SMS receiver implementation
├── domain/
│   ├── usecase/         # Business logic components
│   └── util/            # Helpers (date, strings, contacts, text extraction)
└── ui/
    ├── add_transaction/ # Manual entry UI
    ├── categories/      # Category management & transaction details
    ├── dashboard/       # Spending overview
    ├── debug/           # Debugging utilities for transactions
    ├── providers/       # Transaction sources analysis
    ├── raw_sms_list/    # Listing of raw SMS messages
    ├── settings/        # Application settings
    ├── stats/           # Data statistics screen
    ├── transaction_list/# Full transaction history
    └── visualizations/  # Spending charts
```

### 2. Data Processing Pipeline

#### SMS Extraction Rules (from `Rules for Processing.md` & `TextExtractors.kt`)
```kotlin
// Simplified processing flow:
1. SMS Filtering (SmsDataSource.kt):
   - Exclude messages that don't start with "Bancolombia:" (currently hardcoded in SmsDataSource and SmsReceiver).
   - Keyword-based filtering for financial institutions (e.g., "%Bancolombia%", "%Nequi%") in SmsDataSource.
   - TextExtractors.isPromotionalMessage(body) (checks for URLs or promo keywords) is used in TextExtractors but not directly in SmsDataSource's main read path.

2. Field Extraction (TextExtractors.kt, ExtractTransactionDataUseCase.kt):
   - Date: Primarily from SMS metadata (Telephony.Sms.DATE), fallback to DateTimeUtils.extractDateTimeFromBody(body).
   - Amount: COP currency patterns ($ or COP prefix), e.g., TextExtractors.extractAmountFromBody() & parseToFloat().
   - Provider (ExtractTransactionDataUseCase & TextExtractors.extractProviderFromBody):
     a) Specific patterns (e.g., "de PROVIDER a tu cuenta", "Pagaste ... a PROVIDER desde").
     b) Contact name lookup via phone number (if phone extracted from account info).
     c) General ALL CAPS sequence in message body.
     d) Fallback to SMS sender address (message.address).
   - Contact Name: From phone number lookup if account info yields a phone number (TextExtractors.lookupContactName).
   - Account Info: TextExtractors.detectAccountInfo (various patterns for *XXXX, Nequi, DaviPlata etc.).

3. Transaction Classification (TextExtractors.isIncome):
   - Income detection: body.contains("recibiste", ignoreCase = true).
   - Expense is the default if not income.

4. ID Generation (ExtractTransactionDataUseCase.generateStableId):
   - MD5 hash of "${dateTime.time}-${address}-${body}". Fallback to UUID if MD5 fails.
   - For manual transactions (AddTransactionViewModel), if ID is null, UUID.randomUUID().toString() is used in TransactionRepositoryImpl.addTransaction.
```

### 3. Transaction Handling (Local Persistence)
```kotlin
data class TransactionData(
    val id: String? = null,       // Nullable for new manual entries, generated by repository or use case.
    val userId: String? = null,   // Not currently used with local DB.
    val date: Date,
    val amount: Float,
    val isIncome: Boolean,
    val description: String? = null, // Original SMS body or null for manual entries
    val provider: String? = null,
    val contactName: String? = null,
    val accountInfo: String? = null, // Flattened from AccountInfo model
    var categoryId: String? = null   // Persisted in Room, mapped to CategoryEntity
)
```
- **ID Generation:** As described above (MD5/UUID for SMS, UUID for manual if null).
- **Caching:**
  1. Repositories might hold data in memory briefly, but primary interaction is with Room.
  2. **Room database** serves as the persistent source of truth.
- **Data Storage:** All transaction data is stored in the local Room `transactions` table (via `TransactionEntity`).

### 4. Category System (Local Persistence)
- Default categories are pre-populated in Room on first DB creation (`FinanzasDatabase.onCreate`).
- Custom categories are stored in the Room `categories` table (via `CategoryEntity`).
- "Other" category handling:
  ```kotlin
  // In CategoryRepositoryImpl
  override fun getUncategorizedCategoryPlaceholder(): Category =
      Category(id = null, name = "Other", color = 0xFF808080.toInt(), userId = null)
  // The actual "Other" category in DEFAULT_CATEGORIES has id = "a0a0a0a0-a0a0-a0a0-a0a0-a0a0a0a0a0a0"
  ```
- Assignment persistence using `transactionId → categoryId` mapping within the `TransactionEntity.categoryId` field.
- Provider-to-Category mappings are stored in SharedPreferences via `SharedPrefsManager` and accessed through `CategoryRepository`.

### 5. Provider Analysis (Local Persistence & SharedPreferences)
- Automatic detection from SMS patterns (see Field Extraction).
- Provider name can be manually edited in `TransactionDetailScreen`, updating the specific `TransactionData` instance in Room.
- Provider-to-Category mapping rules can be saved from `TransactionDetailScreen` (via `CategoriesViewModel.saveProviderCategoryPreference`), which stores them in SharedPreferences.
- Stats aggregation (`TransactionRepository.getProviderStats`) by `contactName` then `provider`, queried from Room.

### 6. Spending Visualizations (Local Persistence)
- **Cumulative Spending Chart:** A line chart comparing the cumulative spending of the current month against the previous month.
- **Data Source:** Fetches the last 12 months of transaction data from the local Room database to ensure accurate calculations.
- **Implementation:**
    - `VisualizationsScreen.kt` contains the main Composable UI.
    - `VisualizationViewModel.kt` fetches data via `GetSpendingHistoryUseCase` and processes it into chart-ready data sets.
    - Uses the `MPAndroidChart` library for rendering the line chart.
    - The chart is theme-aware, adapting its colors for light and dark modes.

### 7. Data Statistics (Local Persistence)
- **Stats Screen:** A simple screen displaying key metrics about the stored transaction data.
- **Metrics Displayed:**
    - Total number of transactions in the database.
    - Date of the oldest transaction.
    - Date of the newest transaction.
- **Implementation:**
    - `StatsScreen.kt` displays the data.
    - `StatsViewModel.kt` uses methods from `TransactionRepository` (`getTotalTransactionCount`, `getTransactionDateRange`) to fetch the metrics directly from Room.

## Local Database Schema (Room)

### `TransactionEntity`
```kotlin
@Entity(tableName = "transactions")
data class TransactionEntity(
    @PrimaryKey val id: String,      // Stable ID (MD5 or UUID)
    val userId: String?,             // Currently not used post-Firebase removal
    val date: Long,                  // Store as timestamp for easier querying
    val amount: Float,
    val isIncome: Boolean,
    val description: String?,        // Original SMS body / manual entry description
    val provider: String?,           // Derived/Resolved provider name
    val contactName: String?,        // Matched contact, if any
    val accountInfo: String?,        // Extracted account identifier (e.g., *XXXX)
    var categoryId: String?          // Foreign key to CategoryEntity
)
// Note: originalSmsSender and rawSmsContent from the initial schema are not present.
// description field now serves for SMS body.
```

### `CategoryEntity`
```kotlin
@Entity(tableName = "categories")
data class CategoryEntity(
    @PrimaryKey val id: String, // Can be predefined UUID or auto-generated
    val userId: String?,        // Currently not used
    val name: String,
    val color: Int,             // Store as ARGB Int
)
// Note: isDefault field from initial schema is not present. Default categories are identified by their known IDs/names.
```

(ProviderAliasEntity was in initial plans but not implemented in FinanzasDatabase entities)

## Key Architectural Patterns (Offline-First)
1. **Single Source of Truth (Room):**
   - `TransactionRepository` and `CategoryRepository` interact primarily with Room DAOs for transaction and category data.
   - `CategoryRepository` also uses `SharedPrefsManager` for provider-category mappings.
   - SMS data is processed and immediately inserted/updated in Room.
   - UI observes StateFlows from ViewModels, which source data from Repositories backed by Room queries and SharedPreferences.

2. **Dependency Injection (Hilt):**
   - Hilt for ViewModel creation and injecting dependencies (Repositories, DAOs, UseCases, Context, SharedPrefsManager).
   - `AppModule`, `DatabaseModule`, `RepositoryModule` define bindings.

3. **Error Resiliency:**
   - SMS processing errors are logged; `ExtractTransactionDataUseCase` has a fallback for ID generation if MD5 fails.
   - Database operations are generally wrapped in try-catch blocks in repositories or use cases.

## Required Dependencies (for `app/build.gradle.kts`)
(Assuming these are already correctly in the build.gradle.kts file based on project state)
```gradle
// Room
def room_version = "2.6.1" // Example, use actual version
implementation("androidx.room:room-runtime:$room_version")
kapt("androidx.room:room-compiler:$room_version") // Or ksp
implementation("androidx.room:room-ktx:$room_version")

// SharedPreferences is a built-in Android component, Gson for serialization if complex objects were stored (but here it's for Map<String, String> which is fine)
implementation("com.google.code.gson:gson:2.10.1") // Example for SharedPrefsManager's use of Gson

// Kotlin Coroutines
def coroutines_version = "1.8.0" // Example
implementation("org.jetbrains.kotlinx:kotlinx-coroutines-android:$coroutines_version")

// ViewModel and LiveData/StateFlow
def lifecycle_version = "2.7.0" // Example
implementation("androidx.lifecycle:lifecycle-viewmodel-ktx:$lifecycle_version")
implementation("androidx.lifecycle:lifecycle-runtime-compose:$lifecycle_version") // For collectAsState

// Hilt
def hilt_version = "2.48.1" // Example
implementation("com.google.dagger:hilt-android:$hilt_version")
kapt("com.google.dagger:hilt-compiler:$hilt_version") // Or ksp

// MPAndroidChart
implementation("com.github.PhilJay:MPAndroidChart:v3.1.0")
```

## LLM Context Notes
- This document describes a **fully offline application**. All Firebase/cloud features are removed.
- All monetary values in COP (Colombian Pesos).
- Date formats `dd/MM/yyyy` in UI, stored as `Long` (timestamp) in Room.
- Primary SMS patterns from Bancolombia. Other banks (Nequi, Daviplata) have some patterns but Bancolombia is the most enforced.
- Transaction IDs: Stable for SMS-derived (MD5 hash). For manually added, UUID if not provided.
- Provider-Category rules are persisted in SharedPreferences.
