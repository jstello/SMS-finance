# Rules for processing text messages

## Data Structures
```kotlin
// Core data classes storing processed information
data class SmsMessage(
    val address: String,
    val body: String,
    val amount: String?,         // Extracted currency string (e.g., "COP150000")
    val numericAmount: Float?,   // Converted numeric value (e.g., 150000f)
    val dateTime: java.util.Date?,  // Timestamp from SMS metadata or extracted from body
    val detectedAccount: String? = null,  // Detected account info from SMS body
    val sourceAccount: String? = null,    // Potentially a more specific source account from body
    val recipientContact: String? = null,  // Contact name if a phone number was resolved and matched
    val recipientPhoneNumber: String? = null,  // Phone number extracted from detectedAccount
    val provider: String? = null  // Initial provider from SMS sender, refined later
)

data class TransactionData(
    val id: String? = null, // Nullable for new manual entries, generated by repository or use case.
    val userId: String? = null, // Currently not used with local DB.
    val date: java.util.Date,    // Parsed transaction date
    val amount: Float,           // Numeric amount
    val isIncome: Boolean,       // Income/expense classification
    val description: String? = null,    // Original SMS body or null for manual entries
    val provider: String? = null,       // Detected/extracted/refined provider
    val contactName: String? = null,    // Contact name if resolved from number (can be same as provider)
    val accountInfo: String? = null, // Flattened from detected account info in SMS
    var categoryId: String? = null  // Mutable, mapped to CategoryEntity in Room
)

// Note: AccountInfo data class is also used but not detailed here for brevity.
// It has fields like id, userId, contactName, phoneNumber, accountNumber, bankName.
// In TransactionData, accountInfo is a String?, suggesting a simplified representation.
```

## Date Parsing Logic

-   **Primary Source (SMS Metadata)**: `Telephony.Sms.Inbox.DATE` (long value representing milliseconds since epoch), used in `SmsDataSource`.
-   **Secondary Source (SMS Body Extraction)**: `DateTimeUtils.extractDateTimeFromBody(body: String)` attempts to parse dates like "dd/MM/yyyy HH:mm:ss" or "dd/MM/yyyy HH:mm" from the SMS body. This is used in `SmsDataSource` as a fallback if the body contains a date.
-   The `dateTime` field in `SmsMessage` will hold the date from body extraction if successful, otherwise the metadata timestamp. This `dateTime` is then used for `TransactionData.date`.

## Amount Detection Logic

Handled by `TextExtractors.extractAmountFromBody(body: String)` and `TextExtractors.parseToFloat(amount: String?)`.

```kotlin
// In TextExtractors.kt
fun extractAmountFromBody(body: String): String? {
    // Skips if message is in promoMessageCache
    val pattern = Pattern.compile("""(\\$|COP)\s*((\d{1,3}(?:[.,]\d{3})*|\d+))(?:([.,])(\d{2}))?""")
    val matcher = pattern.matcher(body)
    return if (matcher.find()) {
        val currency = matcher.group(1) // $, COP
        val mainNumber = matcher.group(2)?.replace("[.,]".toRegex(), "") // Remove thousands separators
        val decimal = matcher.group(5) // Decimal part like 00 or 45
        
        when {
            decimal == null -> "$currency$mainNumber" // e.g., $150000
            decimal == "00" -> "$currency$mainNumber" // e.g., COP120000 (from COP120.000,00)
            else -> "$currency$mainNumber.$decimal" // e.g., $123.45
        }
    } else null
}

fun parseToFloat(amount: String?): Float? {
    return amount?.replace("^(\\\$|COP)".toRegex(), "") // Remove $ or COP prefix
        ?.replace(",", ".") // Ensure decimal point is a period for toFloatOrNull
        ?.toFloatOrNull()
}
```

## Transaction Classification (Income/Expense)

Determines if a transaction is an income or an expense, primarily handled by `TextExtractors.isIncome(body: String)`.

```kotlin
// In TextExtractors.kt
fun isIncome(body: String): Boolean {
    // Currently checks only for "recibiste"
    return body.contains("recibiste", ignoreCase = true)
}
// The INCOME_KEYWORDS list in TextExtractors is not directly used by this specific isIncome function.
// ExtractTransactionDataUseCase uses this TextExtractors.isIncome function.
```
Default is expense if not classified as income.

## Account Detection

Handled by `TextExtractors.detectAccountInfo(body: String)` and `TextExtractors.extractPhoneNumberFromAccount(account: String)`.

### `TextExtractors.detectAccountInfo(body: String): Pair<String?, String?>`
Returns a pair: (detectedAccount, sourceAccount). It skips promotional messages based on `promoMessageCache`.
Patterns include (from `TextExtractors.kt`):
- Bancolombia specific: `"a\\s(.+?)\\sdesde\\sproducto\\s([*]\\d+)"` (captures target and source product)
- General account patterns: `"(cuenta|producto|desde)\\s*([*]\\d+)"`, `"a\\s(.+?)\\sdesde"`, etc.

### `TextExtractors.extractPhoneNumberFromAccount(account: String): String?`
Extracts a potential Colombian mobile phone number (10 digits starting with 3) from a detected account string.
Patterns include:
- `"[*]?0{3,}[^0-9]?(3\d{9})"` (e.g., *0000+3001234567 or 0000003001234567)
- General 10-digit numbers starting with 3: `"(\d{10,})"` (then validated starts with '3' and length 10).

## SMS Processing Pipeline

The process of converting raw SMS into `TransactionData`.

**1. `SmsDataSource.readSmsMessages()`**
   - Reads SMS from `Telephony.Sms.CONTENT_URI`.
   - **Filtering**: Messages must start with "Bancolombia:" (case-insensitive). Also applies `bankFilters` (LIKE clauses for keywords like Nequi, Daviplata, transfer, pago, etc.) and optional date range.
   - For each matching SMS, it retrieves: `address`, `body`, `date` (metadata timestamp).
   - Populates an `SmsMessage` object:
     - `SmsMessage.address = address`
     - `SmsMessage.body = body`
     - `SmsMessage.amount = TextExtractors.extractAmountFromBody(body)`
     - `SmsMessage.numericAmount = TextExtractors.parseToFloat(SmsMessage.amount)`
     - `SmsMessage.dateTime = DateTimeUtils.extractDateTimeFromBody(body) ?: java.util.Date(metadata_timestamp)`
     - Account Info (`TextExtractors.detectAccountInfo(body)`):
       - `SmsMessage.detectedAccount`
       - `SmsMessage.sourceAccount`
     - Contact Info (from `detectedAccount` via `TextExtractors.extractPhoneNumberFromAccount` and then `TextExtractors.lookupContactName`):
       - `SmsMessage.recipientPhoneNumber`
       - `SmsMessage.recipientContact`
     - Initial Provider: `SmsMessage.provider = TextExtractors.extractProviderFromBody(body)` (Note: This is different from earlier observation; `SmsDataSource` now directly calls `extractProviderFromBody`).
   - Processes only if `numericAmount != null` or `containsFinancialKeywords(body)` is true.

**2. `ExtractTransactionDataUseCase.execute(messages: List<SmsMessage>)`**
   - Takes a list of `SmsMessage` objects.
   - For each `SmsMessage` (if `dateTime` and `numericAmount` are not null):
     - **Provider Refinement & Contact Name Priority**:
       1. `var provider = TextExtractors.extractProviderFromBody(message.body)` (This seems redundant if `SmsDataSource` already populated `message.provider` using the same method. However, the code does call it again.)
       2. `val (accountInfo, sourceAccount) = TextExtractors.detectAccountInfo(message.body)` (Called again)
       3. `val phoneNumberFromAccount = sourceAccount?.let { TextExtractors.extractPhoneNumberFromAccount(it) }`
       4. `var contactName = phoneNumberFromAccount?.let { TextExtractors.lookupContactName(context, it) }`
       5. If `provider == null && contactName != null`, then `provider = contactName`.
       6. **New Direct Phone Pattern Check**: A regex `"0{4,}(3\d{9})"` is run on `message.body`. If a phone number is found and a contact name (`directContact`) is looked up:
          - `contactName` is updated to `directContact` (prioritized).
          - If `provider` was still null, it's set to `directContact`.
     - **Income Classification**: `val isIncome = TextExtractors.isIncome(message.body)`
     - **ID Generation**: `val stableId = generateStableId("${message.dateTime.time}-${message.address}-${message.body}")` (MD5 or UUID fallback).
     - Creates a `TransactionData` object:
       - `TransactionData.id = stableId`
       - `TransactionData.date = message.dateTime`
       - `TransactionData.amount = message.numericAmount`
       - `TransactionData.isIncome = isIncome`
       - `TransactionData.description = message.body`
       - `TransactionData.provider = provider` (the refined one)
       - `TransactionData.contactName = contactName` (the refined one)
       - `TransactionData.accountInfo = accountInfo` (from the second call to `detectAccountInfo`)
       - `userId` and `categoryId` are null at this stage.

## Enhanced Provider Handling

Provider identification is a multi-step process primarily within `TextExtractors.extractProviderFromBody` and refined in `ExtractTransactionDataUseCase`.

**`TextExtractors.extractProviderFromBody(body: String)` patterns:**
- Destination account: `"a\\s+la\\s+cuenta\\s+\\*?(\d{5,})"` -> extracts account number.
- Company name in transfer: `"a\\s+([A-Za-z][A-Za-z0-9\s&.]+?)\\s+desde\\s+producto"` -> extracts company name.
- Wompi Transfer: `"Transferiste\\s+\\$?[\d.,]+\\s+(?:a|a\\s+la\\s+cuenta\\s+de)\\s+([A-Za-z\s.]+?)(?:\\s+\\*?\d+|...)` -> extracts recipient.
- Bancolombia Income: `"de\\s+(.+?)\\s+(?:a|en)\\s+tu\\s+cuenta"` (also checks for ALL CAPS after "de ").
- Bancolombia Expense: `"(?:Compraste|Pagaste)\\s+(?:\\$|COP)\\s*[\d.,]+\\s+a\\s+(.+?)\\s+desde"` or `"...en\\s+(.+?)\\s+con\\s+tu"` or `"en\\s+((?:[A-Z0-9]|[*])+(?:\\s+[A-Z0-9*]+)*)"`.
- General Expense: `"(?:Compra|Pago)\\s+en\\s+(.+?)(?:\\s+por|...)`.
- General ALL CAPS fallback: Longest uppercase sequence (excluding COP, USD, >3 chars).

**Refinement in `ExtractTransactionDataUseCase`:**
1.  Uses provider from `TextExtractors.extractProviderFromBody()`.
2.  Uses contact name (from phone number in `sourceAccount`) as provider if body extraction yields null.
3.  **Prioritizes contact name derived from direct phone number pattern (`0{4,}(3\d{9})`) in the SMS body** for both `contactName` and `provider` (if provider still null).

**Persistence of Provider-Category Mappings**: Done via `SharedPrefsManager`, accessed through `CategoryRepository` and utilized by `CategoryAssignmentUseCase` and `CategoriesViewModel`.

## Enhanced SMS Filtering
- **`SmsDataSource`**: Filters by `message.body.startsWith("Bancolombia:", ignoreCase = true)` and a list of `bankFilters` using SQL LIKE.
- **`TextExtractors.isPromotionalMessage(body: String)`**: Checks for URLs or promotional keywords. This is used by `TextExtractors` methods like `extractAmountFromBody` and `detectAccountInfo` to skip processing for promotional messages using a cache (`promoMessageCache`). This suggests that even if `SmsDataSource` reads a message, `TextExtractors` might still deem it promotional and not extract data.